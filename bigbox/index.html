<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Can It Be Economically Rational to Restrict Big Box Retailers?
        </title>
    </head>

    <body>
        <div style="text-align:center">
            <p>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Wal-Mart_in_Madison_Heights.jpg/300px-Wal-Mart_in_Madison_Heights.jpg">
            </p>
        </div>
        
        <h1>
            Can It Be Economically Rational to Restrict Big Box Retailers?
        </h1>

        <h2>
            Introduction
        </h2>
            <p>
                Conventional wisdom from committed "free market"
                economists would have it that moves to ban
                "big box" retailers such as Walmart from certain localities
                are rebellions against consumer sovereignty 
                and must hurt consumer welfare. After all,
                if consumers did not want to shop at the big box
                retailer, they would simply not do so, correct?
                The fact that they switch their shopping to the
                big box and away from "mom-and-pop" stores
                shows they prefer the big box.
            </p>

        <h2>
            Theoretical Considerations
        </h2>
            <p>
                This paper attempts to show that the above
                analysis is simplistic.  We present a model
                in which all consumers have the following 
                preference ordering in some retail sector:
            </p>
            <ol>
                <li>Have both local shops and a big box store.
                <li>Have only local shops.
                <li>Have only a big box store.
            </ol>
            <p>
                We then show that, under not outrageous assumptions,
                it is easy for consumers, in trying to achieve their
                first preference, to instead wind up with their third.
                This is due to consumers facing a collective action
                problem, as well as a knowledge problem:
                Consumers might, if they had perfect knowledge
                of the exit points of the local shops and the ability
                to finely coordinate their own shopping with that of others,
                be able to achieve their first preference
                (a mix of big box and mom-and-pop shopping available). But,
                in general consumers have little knowledge of
                how much sales must be reduced before a small shop
                will exit the industry, nor do they have very much
                ability to coordinate their shopping with other consumers.
                (Meaning that even if they forego a certain amount of shopping
                at the big box stores, which they would otherwise do, simply to
                keep the small stores solvent, they cannot ensure their
                neighbors will do the same. So their rational choice is to
                "defect" and shop at the big box store as often as they wish,
                regardless of the impact on the small shops.)
                <br>
                <br>
                Therefore, since they cannot fine tune their
                shopping to achieve 1), they shop at the big box
                store whenever it suits them for a particular
                purchase, without regards to the “macro” effects of their
                choices. They shift "too" much of their shopping to the big
                box, with the end result is that all of 
                the mom-and-pops are driven out of business,
                despite no consumer wanting that result. Thus, 
                t may make sense, faced with such knowledge and
                game theoretic difficulties, for consumers to
                bind themselves in advance to 2), by banning a,
                or some, or all, big box stores, or to trying to
                achieve 1) by, say, forcing big box retailers to
                locate well outside the center of town, making trips
                to them less convenient.
                <br>
                <br>
                We further suggest that our model they actually capture the
                mechanism underlying the intuition of the existence of
                "predatory pricing." As has often been noted, the idea that
                big box stores engage in predatory pricing to drive out small
                competitors and then jack up the prices to achieve high profits
                has an obvious problem: once the prices charge by the big box
                stores have been raised, why don't the small competitors simply
                reenter the market? (See, for instance, DiLorenzo, 1992.)
                <br>
                <br>
                Our model avoids this pitfall: the big box stores do not need
                to set prices below cost: they can rely
                on their greater financial resources to ride out the period
                during which <b>all</b> stores will be losing money,
                and once their smaller competitors have exited,
                they can keep their prices right where they were,
                and now be profitable. And new smaller competitors
                will not enter the market, since that would merely
                reestablish the situation in which all stores are losing money.
            </p>
        <h2>
            Model Design 
        </h2>
            <p>
                We create a model populated by three types of agents:
                consumers (C), mom-and-pops (M), and big-boxes (B).
                The mom-and-pops are further divided by each supplying a
                specific type of good, such as hardware or groceries, while the
                big-boxes provide every sort of good.
                At first "space" is occupied by only M and C. Each supply
                something the other needs to continue in existence: the
                consumers supply money to the mom-and-pop stores, who supply
                goods to the consumers. Ms receive a periodic endowment of
                goods "from heaven" (which is a parameter),
                while Cs have the same thing happen in
                regards to money. Cs shop in turn at each stores selling each
                type of good they need. If Ms run out of money, they disappear.
            </p>

            <p>
                At some point in the progress of the model, the Bs appear. They
                have a much larger initial endowment of money then do the Ms.
                The Cs like both (how much they like each is again a parameter),
                and split their acquisition of goods (according to that
                parameter) between the two types of agents.
                This split causes the money supply of both types of
                agents to dwindle. But as the Bs have much more
                money to start, they are able to survive this period
                of coexistence, while the Ms gradually disappear.
                We are left with an environment of only Bs and Cs,
                which the Cs did <em>not</em> want. Thus, under very
                simple but not outrageous conditions, our model
                shows our story above as plausible: it has what Weber
                would call "explanatory adequacy." Empirical work
                would be necessary to decide whether it has Weberian "causal
                adequacy." (See Callahan and Horwitz, 2010.)
            </p>

        <h2>
            Model Implementation
        </h2>
            
            <h3>
                The Indra System
            </h3>
                    <p>
                        We built our big-box model in Indra. Indra is an
                        open-source framework for creating ABMs,
                        built in Python.
                        Besides the rapid proto-typing benefits of working in
                        Python, and the benefits of open-source, allowing the
                        contributions of many people to the project, and the
                        free availability of all the system's source code,
                        Indra provides many features that are automatically
                        incorporated into every model built in it:
                    </p>
                    <ul>
                        <li>Looping over agents randomly, in order, in reverse
                        order, or by type.
                        <li>Automatic generation of line graphs and scatter
                        plots.
                        <li>The ability to enter model parameters
                        interactively, from the command line, or from a file.
                        <li>The ability to save parameters sets.
                        <li>The ability to dump the state of the system to a
                        JSON file.
                        <li>A built-in, extensible interactive menu.
                        <li>Automatic creation of network graphs showing the
                        relationship among objects in the system.
                        <li>Extensible Markov-matrix capabilities for easily
                        specified, probabilistic behavior on the part of
                        agents.
                        <li>A flexible spacial environment model that allows
                        the composition of agent views of the environment of
                        any desired shape, easing the creation of models
                        exploring limited, local agent knowledge.
                        <li>In-line debugging capabilities, allowing, e.g., the
                        screen display of all of an agent's attributes at any
                        point during the run of a model.
                        <li>The ability to step through a model to watch it
                        develop in real time.
                    </ul>

            <h3>
                Implementing the Big Box Model in Indra
            </h3>
                <h4>
                    Overview
                </h4>
                    <p>
                        In this way, all the action in our model takes place
                        within an environment called, "EverytownUSA;" and the
                        agents in this environment are consumers, mom and pops,
                        and big box stores. Consumers decide where they can
                        shop after polling their environment for what's in
                        their purview.
                    </p>
                    <p>
                        When an agent sees a collection of stores he could
                        possibly go to, he needs some way to choose. Let's say
                        we define his preferences so that when there are
                        multiple places to go, he goes to a mom and pop about
                        70% of the time and to a big box 30% of the time. An
                        option to simulate this is to generate random numbers:
                        If a random number between 0.0 and 1.0 is less than 0.7,
                        the agent goes to the mom and pop; otherwise he goes to
                        the big box. We can do this by use of
                        Indra's Markov classes, which provide the capability
                        to work with a large array of phenomena that are, or,
                        at least, look like, Markov processes.
                    </p>
                    <p>
                        The models run in in unitary steps. On each step,
                        each agent performs his action once. He can act again
                        on the following step. The agents act in random order
                        per step. Consumers act by first looking for places
                        that have what they want, then they choose from these,
                        and then they act on it. Since all kinds of retail
                        store are also agents, these also act each step;
                        and they act by paying rent to the city. If their 
                        funding falls below zero, the city forecloses them, and
                        they are henceforth closed.
                    </p>
                <h4>
                    Detailed Description
                </h4>
                    <p>
                        Instead of a complete description of the code,
                        we'll walk through the shopping logic of the program:
                        how the agents act. Since consumers and retailers have
                        different actions, we'll introduce and elaborate on
                        their actions separately.
                    </p>

                    <p>
                        When a <b>consumer</b> is called forth to act his turn,
                        he surveys the world around him, evaluates his world on
                        the basis of this survey, and he responds according to 
                        his evaluation. Naturally, therefore, we call these
                        methods <code>survey_env</code>, <code>eval_env</code>,
                        and <code>respond_to_cond</code>.
                    </p>

                    <pre>
                    <code>
                        def act(self):
                            env_vars = self.survey_env()
                            eval_vars = self.eval_env(env_vars)
                            if eval_vars:
                                self.respond_to_cond(eval_vars)
                    </code>
                    </pre>

                    <p>
                        The way the consumer surveys his
                        environment goes like this: he finds all the stores
                        he can view (a view which happens to be the whole
                        environment this model) and he only remembers the
                        stores which sell the good he wants.
                    </p>

                    <pre>
                    <code>
                        def survey_env(self):
                            view = self.env.get_square_view(
                                                    center=self.pos,
                                                    distance=math.sqrt(
                                                        self.env.width**2 +
                                                        self.env.height**2))
                            n_census = []
                            n_census.extend(self.neighbor_iter(view=view,
                                                    filt_func=lambda x:
                                                    x.sells(self.goal)))
                            return n_census
                    </code>
                    </pre>

                    <p>
                        After remembering the stores which sell what he wants,
                        the consumer now has to decide where to go. And, as
                        stated above, this choice is simulated through random
                        number generation. First, the consumer assesses his
                        particular preferences.
                    </p>

                    <pre>
                    <code>
                        def eval_env(self, n_census):
                            self.state_pre = self.env.get_pre(self, n_census)
                            self.state_vec = markov.probvec_to_state(
                                                        self.state_pre.matrix)
                            self.state = markov.get_state(self.state_vec)
                            
                            if(self.state == 0):
                                self.preference = MomAndPop
                            if(self.state == 1):
                                self.preference = BigBox

                            for store in n_census:
                                if type(store) is self.preference:
                                    return store                            
                    </code>
                    </pre>

                    <p>
                        Consumers obtain their (ap)prehension from the
                        Environment. We build a 2x1 matrix. The (1,1) 
                        entry represents the agent's chance of going to
                        a <code>mom_and_pop</code>, and the (1,2) entry 
                        is that of the <code>big_box</code>. If a type is
                        not in the agents neighborhood, we cannot go there.
                        Since this means there may be a zero entry, we 
                        must normalize the vector. For the column must sum to
                        1, according to the idea of a transition matrix.
                    <p>

                    <pre>
                    <code>
                            def get_pre(self, agent, n_census):
                            trans_str = ""

                            if(self.there_is(n_census, MomAndPop)):
                                trans_str += "0.7 " 
                            else:
                                trans_str += "0.0 "

                            if(self.there_is(n_census, BigBox)):
                                trans_str += "0.3"
                            else:
                                trans_str += "0.0"

                            state_pre = markov.from_matrix(np.matrix(trans_str))
                            state_pre.matrix = vs.normalize(state_pre.matrix)
                            return state_pre
                    </code>
                    </pre>
                    <p>
                        After choosing where to go,
                        he goes there and buys his long sought after good.
                    </p>

                    <pre>
                    <code>
                        def respond_to_cond(self, store):
                            self.move(store)
                            store.buy_from(self.allowance)
                    </code>
                    </pre>

                    <p>
                        After this action, the consumer
                        now decides his goal is to aquire a new good.
                        This goal is to be acted out during the next cycle of
                        interactions.
                    </p>

                    <pre>
                    <code>
                        def postact(self):
                            """
                            We cycle through the good the agent wants each turn.
                            """
                            self.goal = (self.goal + 1) % NUM_GOODS
                    </code>
                    </pre>

                    <p>
                        The <b>retailer</b>'s action is much simpler. It
                        merely pays its bills. If its funds go below
                        zero, the city forecloses it, and it disappear
                        from the environment never to reappear.
                    </p>

                    <pre>
                    <code>
                    def act(self):
                        self.pay_bills(self.rent)
                        if(self.funds <= 0):
                            self.declare_bankruptcy()
                    </code>
                    </pre>
                    <p>
                        One important fact to note in reading the model is this:
                        since all the agents are called in random order to act,
                        stores might foreclose before a Consumer can save it.
                        In other words, the Consumers do not all act first with
                        Retailers acting second. The actions are intermingled in
                        environment's action cycle.
                    </p>

        <h2>
            Bibliography
        </h2>

            <ul>
                <li>Callahan, Gene and Steven Horwitz.
                    "The Role of Ideal Types in Austrian Business Cycle Theory."
                    In <em>What Is so Austrian about Austrian Economics?</em>,
                    14:205-24. Advances in Austrian
                    Economics 14. Emerald Group Publishing Limited, 2010.
                    http://www.emeraldinsight.com/doi/abs/10.1108/S1529-2134%282010%290000014013.
                <li>DiLoernzo, Thomas. "The Myth of Predatory Pricing."
                    Cato.org, 1992. https://www.cato.org/pubs/pas/pa-169.html.
                <li>Slee, Tom.
                    <em>No One Makes You Shop At Walmart.</em>
                    Between the Lines, 2006.
            </ul>

    </body>
</html>
